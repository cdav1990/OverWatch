# Frontend Coding Standards and Best Practices

## 1. Introduction

This document outlines the coding standards, conventions, and best practices for the OverWatch Mission Control frontend codebase (React + TypeScript). Adhering to these standards ensures consistency, maintainability, readability, and reduces errors.

**Core Principles (Reiteration):**

-   **Simplicity:** Prefer simple, straightforward solutions.
-   **DRY (Don't Repeat Yourself):** Avoid code duplication. Check for existing utilities/hooks/components.
-   **Cleanliness & Organization:** Maintain a clean, well-organized codebase adhering to the defined structure.
-   **Readability:** Write code that is easy for other developers (and AI) to understand.
-   **Performance:** Keep performance in mind, especially for visualization and real-time data.

## 2. Folder Structure

Adhere strictly to the folder structure defined in `02-CoreArchitecture/01-FrontendArchitecture.md`:

```
src/
├── assets/
├── components/ (common/, layout/, mission/, visualization/, hardware/)
├── contexts/
├── hooks/
├── pages/
├── services/ (api/, ros/, workers/)
├── store/
├── types/
├── utils/ (coordinates/, geometry/, formatting/)
├── workers/
└── App.tsx
```

-   Keep files focused. Avoid overly large files (aim for < 300 lines where practical, refactor if significantly larger).

## 3. TypeScript Best Practices

-   **Strict Mode:** Enable and adhere to TypeScript's `strict` mode settings in `tsconfig.json`.
-   **Typing:**
    -   Provide explicit types for all function parameters, return values, and variables where type inference is not obvious or sufficient.
    -   Prefer `interface` for defining the shape of objects and `type` for unions, intersections, primitives, or utility types.
    -   Avoid using `any` unless absolutely necessary and document the reason. Use `unknown` for safer alternatives when types are genuinely unknown.
    -   Use `Readonly` or `readonly` modifiers where appropriate to enforce immutability.
-   **Naming Conventions:**
    -   Interfaces: `PascalCase` (e.g., `interface MissionData`). Prefix with `I` is discouraged.
    -   Types: `PascalCase` (e.g., `type UserRole = 'admin' | 'viewer'`).
    -   Enums: `PascalCase` for enum names, `UPPER_SNAKE_CASE` for members (e.g., `enum Status { NOT_STARTED, IN_PROGRESS }`).
    -   Variables/Functions: `camelCase` (e.g., `const missionId`, `function getMissionData()`).
    -   Constants: `UPPER_SNAKE_CASE` (e.g., `const DEFAULT_ALTITUDE = 100`).
-   **Modules:** Use ES Modules (`import`/`export`). Avoid default exports where possible; prefer named exports for clarity and better tree-shaking.
-   **Utility Types:** Leverage built-in utility types (`Partial`, `Required`, `Pick`, `Omit`, etc.) where appropriate.

## 4. React Best Practices

-   **Functional Components:** Use functional components with Hooks exclusively. Avoid class components.
-   **Hooks:**
    -   Follow the Rules of Hooks (call only at the top level, not inside loops/conditions).
    -   Create custom hooks (`useSomething`) to encapsulate reusable logic and stateful behavior (place in `src/hooks/`).
-   **Props:**
    -   Define prop types explicitly using TypeScript interfaces.
    -   Use object destructuring in function signatures to access props.
    -   Avoid excessive prop drilling; use Context or state management solutions for deeply nested data needs.
-   **Component Composition:** Favor composition over inheritance. Build complex UIs by combining smaller, reusable components.
-   **Keys:** Always provide stable, unique `key` props when rendering lists of elements.
-   **Memoization:** Use `React.memo` for components, `useMemo` for expensive calculations, and `useCallback` for functions passed as props *only when profiling indicates a performance bottleneck*. Avoid premature optimization.
-   **State Management:** Follow the patterns outlined in `01-FrontendArchitecture.md`:
    -   Use `useState` for simple, local component state.
    -   Use `Zustand` (in `src/store/`) for global UI state.
    -   Use `TanStack Query` (hooks in `src/hooks/` or `src/services/api/`) for server state.
    -   Use `Context` (in `src/contexts/`) for localized state shared within a specific component subtree (e.g., theme, hardware controls within a panel).

## 5. Styling

-   **REQUIRED: Use Design Tokens:** All colors, typography settings (font family, size, weight), spacing units, border radii, etc., **MUST** be derived from the official Gecko Robotics design tokens provided by the `Figma-Style-Dictionary` package.
-   **Theme Integration:** These design tokens **MUST** be integrated into the application's theme configuration, presumably using `gecko-ui`'s theming capabilities. Theme variables generated by the Style Dictionary build process should be mapped to the `gecko-ui` theme structure.
-   **Component Library:** Use `gecko-ui` components (`git@github.com:GeckoRobotics/gecko-ui.git`) as the **primary** source for all UI building blocks (buttons, inputs, layout, etc.).
-   **Styling Implementation:** Utilize `gecko-ui`'s provided styling mechanisms (e.g., props, theme overrides, associated CSS conventions). Reference theme variables derived from `Figma-Style-Dictionary` instead of hardcoding values.
-   **Avoid Inline Styles:** Avoid using the `style` prop with hardcoded values whenever possible. Use theme-aware styling solutions provided by `gecko-ui` or the theme.
-   **Consistency:** Ensure visual consistency across the application by strictly adhering to the components and theme defined by `gecko-ui` and `Figma-Style-Dictionary`.

## 6. Asynchronous Operations

-   Use `async/await` for handling Promises.
-   Use `TanStack Query` for managing async data fetching state (loading, error, success).
-   Implement consistent error handling for API calls within service functions or TanStack Query mutations/queries.

## 7. Error Handling

-   Use `try...catch` blocks for operations that can throw expected errors (e.g., API calls, parsing).
-   Propagate errors appropriately; don't swallow exceptions silently.
-   Implement UI error boundaries at logical points in the component tree.
-   Display user-friendly error messages; log detailed errors to the console or a logging service.

## 8. Code Formatting and Linting

-   **Automatic Formatting:** Rely on Prettier (configured in `package.json` or `.prettierrc`) to format code automatically on save and via pre-commit hooks.
-   **Linting:** Adhere to ESLint rules (configured in `.eslintrc.js` or similar). Address all linting errors and warnings.
-   **Fix Errors:** Do not commit code with linting or TypeScript errors.

## 9. Comments

-   Write self-documenting code where possible.
-   Avoid obvious comments (e.g., `// increment count`).
-   Use comments primarily to explain *why* something is done a certain way if it's non-intuitive, or to explain complex algorithms.
-   Use JSDoc comments (`/** ... */`) for exported functions, types, and complex internal functions to describe parameters, return values, and purpose.

## 10. Library-Specific Patterns

-   **Zustand:** Define stores in `src/store/`. Keep stores focused on specific domains. Use slices if stores become too large.
-   **TanStack Query:** Define query keys carefully using array structures for hierarchical caching. Define custom hooks for reusable queries/mutations.
-   **Babylon.js:** Implement proper resource cleanup (calling `dispose()` on geometries, materials, textures) when objects are removed from the scene, especially within the Web Worker.
-   **gecko-ui:** Follow recommended patterns for using `gecko-ui` components, including prop usage, composition, and overriding styles via its theming mechanism. Refer to `gecko-ui` documentation (if available).

## 11. Environment Awareness

-   Use environment variables (`import.meta.env.VITE_...`) for configuration that differs between environments (dev, staging, prod).
-   Do not commit sensitive credentials or keys directly into the codebase.
-   Ensure features behave correctly across different environment configurations.

## 12. Testing

-   Write unit tests (Jest/RTL) for utility functions, custom hooks, and complex component logic.
-   Write integration tests (RTL) for components interacting with state management or services.
-   Aim for meaningful test coverage, focusing on critical paths and logic.

## 13. Accessibility (a11y)

-   Use semantic HTML elements where appropriate.
-   Ensure interactive elements are keyboard-navigable and focusable.
-   Provide appropriate ARIA attributes when needed.
-   Leverage MUI's built-in accessibility features.

This document is a living guide and may be updated as the project evolves. 