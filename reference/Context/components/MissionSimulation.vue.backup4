<template>
  <div v-if="isVisible" class="mission-simulation-panel" :style="panelStyle">
    <div class="header" @mousedown="startDrag" ref="headerRef">
      <h2 class="panel-title">Mission Simulation</h2>
      <v-btn icon size="small" @click="closePanel">
        <v-icon>mdi-close</v-icon>
      </v-btn>
    </div>
    
    <div class="simulation-content">
      <!-- Animation controls at the top -->
      <div class="simulation-controls mb-4">
        <v-select
          v-model="selectedMissionType"
          :items="missionTypes"
          label="Mission Type"
          variant="outlined"
          density="compact"
          bg-color="rgba(0, 0, 0, 0.7)"
          color="warning"
          class="mission-select"
        ></v-select>
        
        <v-btn-group class="animation-controls">
          <v-btn color="primary" icon="mdi-home" @click="returnToHomePosition" title="Return to Home"></v-btn>
          <v-btn color="primary" icon="mdi-rewind" @click="restartAnimation" title="Restart"></v-btn>
          <v-btn color="primary" :icon="isPlaying ? 'mdi-pause' : 'mdi-play'" @click="toggleAnimation" title="Play/Pause"></v-btn>
        </v-btn-group>
      </div>
      
      <div class="mission-settings">
        <!-- Flight parameters settings -->
        <div class="section">
          <div class="section-header" @click="flightParamsExpanded = !flightParamsExpanded">
            <h4 class="section-title">Flight Parameters</h4>
            <span class="toggle-icon">{{ flightParamsExpanded ? 'â–¼' : 'â–¶' }}</span>
          </div>
          <div v-show="flightParamsExpanded" class="section-content">
            <!-- Takeoff Location - integrated into Flight Parameters -->
            <div class="settings-column mb-3">
              <h4 class="settings-subtitle">Takeoff Location</h4>
              <div v-if="hasTakeoffLocation" class="takeoff-info">
                <div class="info-stat">
                  <span class="info-label">Status:</span>
                  <span class="info-value success-text">Takeoff Location Set</span>
                </div>
                <div class="info-stat" v-if="missionStore.takeoffLocation">
                  <span class="info-label">Coordinates:</span>
                  <span class="info-value">
                    {{ formatCoordinate(missionStore.takeoffLocation.lat) }}, 
                    {{ formatCoordinate(missionStore.takeoffLocation.lng) }}
                  </span>
                </div>
                <v-btn 
                  color="warning" 
                  size="small" 
                  prepend-icon="mdi-map-marker" 
                  class="mt-2"
                  @click="selectTakeoffLocation"
                >
                  Change Location
                </v-btn>
              </div>
              <div v-else class="takeoff-missing">
                <div class="warning-message">
                  <v-icon color="warning" icon="mdi-alert-circle-outline"></v-icon>
                  <span>No takeoff location set.</span>
                </div>
                <v-btn 
                  color="warning" 
                  block 
                  prepend-icon="mdi-map-marker" 
                  class="mt-3"
                  @click="selectTakeoffLocation"
                >
                  Select Takeoff Location
                </v-btn>
              </div>
            </div>
            
            <div class="settings-grid">
              <div class="settings-column">
                <h4 class="settings-subtitle">Takeoff</h4>
                <div class="input-row">
                  <v-text-field
                    v-model.number="startingAltitude"
                    label="Initial Altitude (m)"
                    type="number"
                    min="5"
                    max="120"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="Height to climb before mission starts"
                    persistent-hint
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="climbSpeed"
                    label="Climb Speed (m/s)"
                    type="number"
                    min="1"
                    max="10"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                  ></v-text-field>
                </div>
              </div>
              
              <div class="settings-column">
                <h4 class="settings-subtitle">Mission Speed</h4>
                <div class="input-row">
                  <v-text-field
                    v-model.number="missionSpeed"
                    label="Mission Speed (m/s)"
                    type="number"
                    min="1"
                    max="20"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="Speed during data capture"
                    persistent-hint
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="transitSpeed"
                    label="Transit Speed (m/s)"
                    type="number"
                    min="1"
                    max="20"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="Speed between waypoints"
                    persistent-hint
                  ></v-text-field>
                </div>
              </div>
              
              <div class="settings-column">
                <h4 class="settings-subtitle">Return to Home</h4>
                <v-select
                  v-model="returnToHome"
                  :items="returnToHomeOptions"
                  label="RTH Behavior"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                  class="setting-control mb-3"
                ></v-select>
                
                <v-select
                  v-model="lossOfCommsBehavior"
                  :items="lossOfCommsBehaviorOptions"
                  label="Loss of Comms"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                  class="setting-control"
                  hint="Behavior if drone loses connection"
                  persistent-hint
                ></v-select>
              </div>

              <div class="settings-column">
                <h4 class="settings-subtitle">Speed Settings</h4>
                <v-slider
                  v-model="simulationSpeed"
                  :min="1"
                  :max="10"
                  :step="1"
                  color="warning"
                  show-ticks="always"
                  thumb-label
                  label="Simulation Speed"
                ></v-slider>
              </div>
            </div>
            
            <v-btn color="primary" block class="mt-4" @click="saveFlightParameters">
              Save Flight Parameters
            </v-btn>
          </div>
        </div>
        
        <!-- Camera and GSD Settings Section -->
        <div class="section">
          <div class="section-header" @click="hardwareInfoExpanded = !hardwareInfoExpanded">
            <h4 class="section-title">Mission Hardware Info</h4>
            <span class="toggle-icon">{{ hardwareInfoExpanded ? 'â–¼' : 'â–¶' }}</span>
          </div>
          <div v-show="hardwareInfoExpanded" class="section-content">
            <div v-if="!missionStore.hardware || !missionStore.hardware.cameraDetails" class="hardware-notice">
              <v-alert
                type="warning"
                variant="tonal"
                icon="mdi-alert-circle-outline"
                class="mb-3"
              >
                Please go back to Step 3 (Mission Hardware) to set up your drone, camera, and lens.
              </v-alert>
              <div class="d-flex justify-center">
                <v-btn color="warning" @click="navigateToHardwareSelection">
                  Go to Hardware Selection
                </v-btn>
              </div>
            </div>
            
            <div v-else>
              <!-- Hardware Info -->
              <div class="hardware-info-grid">
                <div class="info-section">
                  <h4 class="settings-subtitle">Drone</h4>
                  <div class="info-value">{{ missionStore.hardware.droneDetails?.name || 'Not selected' }}</div>
                </div>
                <div class="info-section">
                  <h4 class="settings-subtitle">Camera</h4>
                  <div class="info-value">
                    {{ missionStore.hardware.cameraDetails ? `${missionStore.hardware.cameraDetails.brand} ${missionStore.hardware.cameraDetails.model}` : 'Not selected' }}
                  </div>
                </div>
                <div class="info-section">
                  <h4 class="settings-subtitle">Lens</h4>
                  <div class="info-value">
                    {{ missionStore.hardware.lensDetails ? `${missionStore.hardware.lensDetails.brand} ${missionStore.hardware.lensDetails.model} (${missionStore.hardware.lensDetails.focalLength}mm)` : 'Not selected' }}
                  </div>
                </div>
              </div>
              
              <!-- Photogrammetry Parameters from Mission Hardware -->
              <div class="results-panel mt-4" v-if="photogrammetryParameters">
                <h4 class="settings-subtitle">Photogrammetry Parameters</h4>
                <div class="results-grid">
                  <div class="result-item">
                    <span class="result-label">GSD:</span>
                    <span class="result-value">{{ photogrammetryParameters.gsd ? photogrammetryParameters.gsd.toFixed(2) : '-' }} cm/px</span>
                  </div>
                  <div class="result-item">
                    <span class="result-label">Footprint:</span>
                    <span class="result-value">{{ photogrammetryParameters.footprint ? (photogrammetryParameters.footprint.width.toFixed(1) + ' Ã— ' + photogrammetryParameters.footprint.height.toFixed(1) + ' m') : '-' }}</span>
                  </div>
                  <div class="result-item">
                    <span class="result-label">Image Spacing:</span>
                    <span class="result-value">{{ photogrammetryParameters.imageSpacing ? photogrammetryParameters.imageSpacing.toFixed(1) : '-' }} m (forward)</span>
                  </div>
                  <div class="result-item">
                    <span class="result-label">Track Spacing:</span>
                    <span class="result-value">{{ photogrammetryParameters.trackSpacing ? photogrammetryParameters.trackSpacing.toFixed(1) : '-' }} m (side)</span>
                  </div>
                  <div class="result-item">
                    <span class="result-label">Images per Ha:</span>
                    <span class="result-value">{{ photogrammetryParameters.imagesPerHectare ? Math.ceil(photogrammetryParameters.imagesPerHectare) : '-' }}</span>
                  </div>
                </div>
              </div>
              
              <div class="mt-4">
                <v-alert
                  type="info"
                  variant="tonal"
                  icon="mdi-information-outline"
                  density="compact"
                >
                  To change camera or drone settings, please go back to Step 3 (Mission Hardware).
                </v-alert>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Object Info Settings Section -->
        <div v-if="pattern === 'building-scan'" class="section">
          <div class="section-header" @click="objectInfoExpanded = !objectInfoExpanded">
            <h4 class="section-title">Object Info Settings</h4>
            <span class="toggle-icon">{{ objectInfoExpanded ? 'â–¼' : 'â–¶' }}</span>
          </div>
          <div v-show="objectInfoExpanded" class="section-content">
            <div class="settings-grid">
              <div class="settings-column">
                <h4 class="settings-subtitle">Object Dimensions</h4>
                <div class="input-row">
                  <v-text-field
                    v-model.number="buildingWidth"
                    label="Width (m)"
                    type="number"
                    min="5"
                    max="500"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="buildingLength"
                    label="Length (m)"
                    type="number"
                    min="5"
                    max="500"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="buildingHeight"
                    label="Height (m)"
                    type="number"
                    min="5"
                    max="500"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                  ></v-text-field>
                </div>
                
                <!-- Object Color in Object Dimensions section -->
                <v-select
                  v-model="objectColor"
                  :items="['blue', 'red', 'green', 'yellow', 'purple', 'orange']"
                  label="Object Color"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                  class="mt-3"
                ></v-select>
                
                <!-- Object Creation Button -->
                <v-btn 
                  color="success" 
                  block 
                  class="mt-3" 
                  prepend-icon="mdi-cube-outline"
                  @click="createScanObject"
                >
                  Create 3D Object
                </v-btn>
              </div>
              
                </div>
              </div>
            </div>
            <!-- Removed button -->
          </div>
        </div>
        
        <!-- Pattern Options Section (moved after Object Info) -->
        <div class="section pattern-options">
          <div class="section-header" @click="patternOptionsExpanded = !patternOptionsExpanded">
            <h4 class="section-title">Pattern Options</h4>
            <span class="toggle-icon">{{ patternOptionsExpanded ? 'â–¼' : 'â–¶' }}</span>
          </div>
          <div v-show="patternOptionsExpanded" class="section-content">
            <div class="pattern-types">
              <v-tabs v-model="patternType" color="warning">
                <v-tab value="2d">2D Patterns</v-tab>
                <v-tab value="3d">3D Patterns</v-tab>
              </v-tabs>
              
              <v-window v-model="patternType">
                <v-window-item value="2d">
                  <div class="pattern-buttons">
                    <v-btn 
                      prepend-icon="mdi-view-grid" 
                      color="primary" 
                      :variant="pattern === 'grid' ? 'elevated' : 'outlined'"
                      @click="setPattern('grid')"
                    >
                      Grid
                    </v-btn>
                    <v-btn 
                      prepend-icon="mdi-arrow-u-right-top" 
                      color="primary" 
                      :variant="pattern === 'lawnmower' ? 'elevated' : 'outlined'"
                      @click="setPattern('lawnmower')"
                    >
                      Lawn Mower
                    </v-btn>
                    <v-btn 
                      prepend-icon="mdi-spiral" 
                      color="primary" 
                      :variant="pattern === 'spiral' ? 'elevated' : 'outlined'"
                      @click="setPattern('spiral')"
                    >
                      Spiral
                    </v-btn>
                  </div>
                </v-window-item>
                
                <v-window-item value="3d">
                  <div class="pattern-buttons">
                    <v-btn 
                      prepend-icon="mdi-cube-scan" 
                      color="primary" 
                      :variant="pattern === 'building-scan' ? 'elevated' : 'outlined'"
                      @click="setPattern('building-scan')"
                    >
                      Object Info
                    </v-btn>
                    <v-btn 
                      prepend-icon="mdi-rotate-3d" 
                      color="primary" 
                      :variant="pattern === 'orbit' ? 'elevated' : 'outlined'"
                      @click="setPattern('orbit')"
                    >
                      Orbit
                    </v-btn>
                    <v-btn 
                      prepend-icon="mdi-stairs" 
                      color="primary" 
                      :variant="pattern === 'spiral' ? 'elevated' : 'outlined'"
                      @click="setPattern('spiral')"
                    >
                      Spiral
                    </v-btn>
                    <v-btn 
                      prepend-icon="mdi-view-sequential" 
                      color="primary" 
                      :variant="pattern === 'facade' ? 'elevated' : 'outlined'"
                      @click="setPattern('facade')"
                    >
                      Facade
                    </v-btn>
                  </div>
                </v-window-item>
              </v-window>
            </div>
            
            <!-- Add Generate Pattern Button -->
            <v-btn color="primary" block class="mt-4" prepend-icon="mdi-map-marker-path" @click="calculatePattern">
              Generate Flight Pattern
            </v-btn>
          </div>
        </div>
        
        <!-- Orbit Pattern Settings -->
        <div v-if="pattern === 'orbit'" class="section">
          <div class="section-header" @click="objectInfoExpanded = !objectInfoExpanded">
            <h4 class="section-title">Orbit Settings</h4>
            <span class="toggle-icon">{{ objectInfoExpanded ? 'â–¼' : 'â–¶' }}</span>
          </div>
          <div v-show="objectInfoExpanded" class="section-content">
          <div class="settings-grid">
            <div class="settings-column">
                <h4 class="settings-subtitle">Target Point</h4>
                <v-btn 
                  color="warning" 
                  prepend-icon="mdi-cursor-default-click-outline"
                  block
                  class="mb-3"
                  @click="selectOrbitTarget"
                >
                  Click to Select Target on Map
                </v-btn>
              <div class="input-row">
                <v-text-field
                    v-model.number="orbitCenterX"
                    label="Target X (m)"
                    type="number"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="X coordinate relative to takeoff"
                    persistent-hint
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="orbitCenterZ"
                    label="Target Z (m)"
                    type="number"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="Z coordinate relative to takeoff"
                    persistent-hint
                  ></v-text-field>
                </div>
              </div>
              
              <div class="settings-column">
                <h4 class="settings-subtitle">Orbit Parameters</h4>
                <div class="input-row">
                  <v-text-field
                    v-model.number="orbitRadius"
                    label="Radius (m)"
                  type="number"
                  min="5"
                    max="100"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="orbitAltitude"
                    label="Altitude (m)"
                    type="number"
                    min="10"
                  max="120"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                  ></v-text-field>
                </div>
              </div>
              
              <div class="settings-column">
                <h4 class="settings-subtitle">Camera Settings</h4>
                <v-select
                  v-model="orbitCameraMode"
                  :items="orbitCameraModes"
                  label="Camera Mode"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                  class="setting-control mb-3"
                ></v-select>
                
                <v-text-field
                  v-model.number="orbitCameraAngle"
                  label="Camera Pitch (Â°)"
                  type="number"
                  min="-90"
                  max="0"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                  hint="-90Â° = straight down, 0Â° = horizontal"
                  persistent-hint
                ></v-text-field>
              </div>
            </div>
                
            <div class="settings-grid mt-4">
              <div class="settings-column">
                <h4 class="settings-subtitle">Advanced</h4>
                <div class="input-row">
                <v-text-field
                    v-model.number="orbitCount"
                    label="Num Orbits"
                  type="number"
                  min="1"
                  max="10"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                ></v-text-field>
                  
                  <v-text-field
                    v-model.number="orbitVerticalShift"
                    label="Vertical Shift (m)"
                    type="number"
                    min="-10"
                    max="10"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="Altitude change per orbit"
                    persistent-hint
                ></v-text-field>
              </div>
            </div>
            
            <div class="settings-column">
                <h4 class="settings-subtitle">Waypoints</h4>
                <v-text-field
                  v-model.number="orbitSegments"
                  label="Segments"
                  type="number"
                  min="8"
                  max="48"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                  hint="More segments = smoother flight"
                  persistent-hint
                ></v-text-field>
              </div>
            </div>
            
            <v-btn color="primary" block class="mt-4" @click="calculatePattern">
              Generate Orbit Pattern
            </v-btn>
          </div>
        </div>

        <!-- Spiral Pattern Settings -->
        <div v-if="pattern === 'spiral'" class="section">
          <div class="section-header" @click="objectInfoExpanded = !objectInfoExpanded">
            <h4 class="section-title">Spiral Settings</h4>
            <span class="toggle-icon">{{ objectInfoExpanded ? 'â–¼' : 'â–¶' }}</span>
          </div>
          <div v-show="objectInfoExpanded" class="section-content">
            <div class="settings-grid">
              <div class="settings-column">
                <h4 class="settings-subtitle">Center Point</h4>
              <div class="input-row">
                <v-text-field
                    v-model.number="spiralCenterX"
                    label="Center X (m)"
                  type="number"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                    hint="X coordinate relative to takeoff"
                  persistent-hint
                ></v-text-field>
                
                <v-text-field
                    v-model.number="spiralCenterZ"
                    label="Center Z (m)"
                  type="number"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                    hint="Z coordinate relative to takeoff"
                  persistent-hint
                ></v-text-field>
              </div>
            </div>
            
            <div class="settings-column">
                <h4 class="settings-subtitle">Radius</h4>
                <div class="input-row">
                  <v-text-field
                    v-model.number="spiralStartRadius"
                    label="Start Radius (m)"
                    type="number"
                    min="5"
                    max="100"
                variant="outlined"
                density="compact"
                bg-color="rgba(0, 0, 0, 0.7)"
                color="warning"
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="spiralEndRadius"
                    label="End Radius (m)"
                    type="number"
                    min="5"
                    max="100"
                variant="outlined"
                density="compact"
                bg-color="rgba(0, 0, 0, 0.7)"
                color="warning"
                  ></v-text-field>
                </div>
              </div>
              
              <div class="settings-column">
                <h4 class="settings-subtitle">Altitude</h4>
                <div class="input-row">
                  <v-text-field
                    v-model.number="spiralStartAltitude"
                    label="Start Alt (m)"
                    type="number"
                    min="10"
                    max="120"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="spiralEndAltitude"
                    label="End Alt (m)"
                    type="number"
                    min="10"
                    max="120"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                  ></v-text-field>
                </div>
              </div>
            </div>
            
            <div class="settings-grid mt-4">
              <div class="settings-column">
                <h4 class="settings-subtitle">Pattern</h4>
                <div class="input-row">
                  <v-text-field
                    v-model.number="spiralRevolutions"
                    label="Revolutions"
                    type="number"
                    min="1"
                    max="10"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="Number of complete turns"
                persistent-hint
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="spiralSegments"
                    label="Segments"
                    type="number"
                    min="20"
                    max="100"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="More segments = smoother spiral"
                    persistent-hint
                  ></v-text-field>
                </div>
            </div>
          </div>
          
            <v-btn color="primary" block class="mt-4" @click="calculatePattern">
              Generate Spiral Pattern
          </v-btn>
          </div>
        </div>
        
        <!-- Facade Scan Pattern Settings -->
        <div v-if="pattern === 'facade'" class="section">
          <div class="section-header" @click="objectInfoExpanded = !objectInfoExpanded">
            <h4 class="section-title">Facade Scan Settings</h4>
            <span class="toggle-icon">{{ objectInfoExpanded ? 'â–¼' : 'â–¶' }}</span>
          </div>
          <div v-show="objectInfoExpanded" class="section-content">
          <div class="settings-grid">
              <div class="settings-column">
                <h4 class="settings-subtitle">Building Location</h4>
                <div class="input-row">
                  <v-text-field
                    v-model.number="facadeCenterX"
                    label="Center X (m)"
                    type="number"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="X coordinate relative to takeoff"
                    persistent-hint
                  ></v-text-field>
                  
                  <v-text-field
                    v-model.number="facadeCenterZ"
                    label="Center Z (m)"
                    type="number"
                    variant="outlined"
                    density="compact"
                    bg-color="rgba(0, 0, 0, 0.7)"
                    color="warning"
                    hint="Z coordinate relative to takeoff"
                    persistent-hint
                  ></v-text-field>
                </div>
              </div>
              
            <div class="settings-column">
              <h4 class="settings-subtitle">Building Dimensions</h4>
              <div class="input-row">
                <v-text-field
                    v-model.number="facadeWidth"
                    label="Width (m)"
                  type="number"
                    min="5"
                    max="100"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                ></v-text-field>
                
                <v-text-field
                    v-model.number="facadeHeight"
                    label="Height (m)"
                  type="number"
                    min="5"
                    max="100"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                ></v-text-field>
              </div>
            </div>
            
            <div class="settings-column">
              <h4 class="settings-subtitle">Scan Settings</h4>
              <div class="input-row">
                <v-text-field
                    v-model.number="facadeScanDistance"
                    label="Distance (m)"
                  type="number"
                  min="5"
                    max="30"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                    hint="Distance from building"
                    persistent-hint
                ></v-text-field>
                
                <v-text-field
                    v-model.number="facadeOverlap"
                  label="Overlap (%)"
                  type="number"
                  min="0"
                    max="80"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                ></v-text-field>
                </div>
              </div>
            </div>
            
            <div class="settings-grid mt-4">
            <div class="settings-column">
                <h4 class="settings-subtitle">Orientation</h4>
                <v-text-field
                  v-model.number="facadeOrientation"
                  label="Rotation (Â°)"
                  type="number"
                  min="0"
                  max="360"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                color="warning"
                  hint="Building rotation"
                  persistent-hint
                ></v-text-field>
              </div>
              
              <!-- Add Face Selection Section -->
              <div class="settings-column">
                <h4 class="settings-subtitle">Face Selection</h4>
                <v-select
                  v-model="selectedFaces"
                  :items="facadeOptions"
                  label="Select Faces to Scan"
                  variant="outlined"
                  density="compact"
                  bg-color="rgba(0, 0, 0, 0.7)"
                  color="warning"
                  multiple
                  chips
                  hint="Select building faces to scan"
                  persistent-hint
                ></v-select>
                
                <div class="face-selection-visual mt-3">
                  <div class="building-top-view">
                    <div 
                      v-for="(face, index) in ['North', 'East', 'South', 'West']" 
                      :key="index"
                      :class="['building-face', 'face-' + index, {selected: selectedFaces.includes(face)}]"
                      @click="toggleFaceSelection(face)"
                    >
                      {{ face.charAt(0) }}
                    </div>
                    <div class="building-center"></div>
                  </div>
                  <div class="text-caption text-center mt-2">Top View (click to select/deselect)</div>
                </div>
            </div>
          </div>
          
            <!-- Remove the combined calculation button -->
          </div>
        </div>
      </div>
      
      <div class="mission-info" v-if="patternCalculated">
        <div class="simulation-progress">
          <div class="progress-info">
            <div class="info-stat">
              <span class="info-label">Waypoints:</span>
              <span class="info-value">{{ simulationWaypoints.length }}</span>
            </div>
            <div class="info-stat">
              <span class="info-label">Current:</span>
              <span class="info-value">{{ currentWaypointIndex + 1 }}/{{ simulationWaypoints.length }}</span>
            </div>
            <div class="info-stat">
              <span class="info-label">Flight Time:</span>
              <span class="info-value">{{ flightTimeDisplay }}</span>
            </div>
            <div class="info-stat">
              <span class="info-label">Coverage:</span>
              <span class="info-value">{{ coverageArea.toFixed(1) }} ftÂ²</span>
            </div>
          </div>
          
          <v-progress-linear v-model="animationProgress" color="warning" height="8"></v-progress-linear>
        </div>
      </div>
    </div>
  </div>
  
  <v-dialog v-model="takeoffPromptVisible" persistent max-width="400px">
    <v-card>
      <v-card-title class="headline">
        Set Takeoff Location
      </v-card-title>
      <v-card-text>
        Please set a takeoff location before generating a pattern. This will be the starting and ending point for the mission.
      </v-card-text>
      <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn color="primary" variant="outlined" @click="selectTakeoffLocation">
          Select Takeoff Location
        </v-btn>
      </v-card-actions>
    </v-card>
  </v-dialog>
  
  <!-- GSD Information Dialog -->
  <v-dialog v-model="showGSDInfo" max-width="600px">
    <v-card>
      <v-card-title class="headline">
        Ground Sampling Distance (GSD)
      </v-card-title>
      <v-card-text>
        <p class="mb-3">
          <b>GSD</b> is the distance between the centers of two consecutive pixels measured on the ground. It determines the level of detail captured in your photogrammetry images.
        </p>
        
        <div class="info-subtitle">How it's calculated:</div>
        <p class="mb-3">
          GSD = (Sensor Width Ã— Flight Height Ã— 100) Ã· (Focal Length Ã— Image Width)
        </p>
        
        <div class="info-subtitle">What it means:</div>
        <ul class="mb-4">
          <li><b>Lower GSD</b> (e.g., 1 cm/px): Higher resolution, more detail, requires flying lower or using a better camera</li>
          <li><b>Higher GSD</b> (e.g., 5 cm/px): Lower resolution, less detail, allows flying higher and covering more area</li>
        </ul>
        
        <div class="info-subtitle">Recommended GSD values:</div>
        <ul>
          <li><b>High Detail</b> (buildings, infrastructure): 1-2 cm/px</li>
          <li><b>Medium Detail</b> (general mapping): 2-5 cm/px</li>
          <li><b>Low Detail</b> (large area survey): 5-10 cm/px</li>
        </ul>
      </v-card-text>
      <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn color="primary" @click="showGSDInfo = false">Close</v-btn>
      </v-card-actions>
    </v-card>
  </v-dialog>

</template>

<script setup>
import { ref, computed, watch, onMounted, onBeforeUnmount, nextTick } from 'vue'
import { useMissionStore } from '../store/missionStore'
import { showNotification, showSuccessNotification } from '../utils/notifications'
import * as FlightPatterns from '../utils/flightPatterns'
import { toRaw } from 'vue'
import { 
  calculateGSD, 
  calculateFootprint, 
  calculateFieldOfView, 
  calculateImageSpacing,
  calculateAltitudeForGSD, 
  calculateFacadeParameters 
} from '../utils/gsdCalculations'

const { generateOrbit, generateSpiral, generateFacadeScan: flightPatternFacadeScan, convertToMissionWaypoints } = FlightPatterns;

// Define props
const props = defineProps({
  initialX: {
    type: Number,
    default: 100
  },
  initialY: {
    type: Number,
    default: 100
  }
})

// Define panel state
const emit = defineEmits(['close'])
const isVisible = ref(true)
const isDragging = ref(false)
const headerRef = ref(null)
const dragOffset = ref({ x: 0, y: 0 })
const panelPosition = ref({ x: props.initialX, y: props.initialY })

// Mission simulation state
const missionStore = useMissionStore()
const simulationWaypoints = ref([])
const currentWaypointIndex = ref(0)
const animationProgress = ref(0)
const isPlaying = ref(false)
const animationTimer = ref(null)
const patternCalculated = ref(false)
const coverageArea = ref(0)
const simulationSpeed = ref(1)
const takeoffPromptVisible = ref(false)

// Interface state
const selectedMissionType = ref('building-inspection')
const patternType = ref('3d')
const pattern = ref('building-scan')
const missionTypes = ['aerial-mapping', 'building-inspection', 'infrastructure-inspection']

// Flight parameters
const startingAltitude = ref(50)
const climbSpeed = ref(3)
const missionSpeed = ref(5)
const transitSpeed = ref(7)
const returnToHome = ref('takeoff')
const returnToHomeOptions = [
  { title: 'Return to Takeoff', value: 'takeoff' },
  { title: 'Land at Last Waypoint', value: 'last_waypoint' }
]
const lossOfCommsBehavior = ref('rtl')
const lossOfCommsBehaviorOptions = [
  { title: 'Return to Home', value: 'rtl' },
  { title: 'Land in Place', value: 'land' },
  { title: 'Continue Mission', value: 'continue' }
]

// Building scan parameters
const buildingWidth = ref(100)
const buildingLength = ref(300)
const buildingHeight = ref(300)
const scanDistance = ref(30)
const overlap = ref(20)
const objectColor = ref('blue')
const objectColorOptions = [
  { title: 'Red', value: 'red' },
  { title: 'Green', value: 'green' },
  { title: 'Blue', value: 'blue' },
  { title: 'Yellow', value: 'yellow' },
  { title: 'Orange', value: 'orange' },
  { title: 'Gray', value: 'gray' }
]

// Orbit pattern parameters
const orbitCenterX = ref(0)
const orbitCenterZ = ref(0)
const orbitRadius = ref(30)
const orbitAltitude = ref(60)
const orbitCameraMode = ref('center')
const orbitCameraModes = [
  { title: 'Point at Target', value: 'center' },
  { title: 'Forward Facing', value: 'forward' },
  { title: 'Fixed Angle', value: 'custom' }
]
const orbitCameraAngle = ref(-45)
const orbitSegments = ref(16)
const orbitCount = ref(1)
const orbitVerticalShift = ref(5)

// Spiral pattern parameters
const spiralCenterX = ref(0)
const spiralCenterZ = ref(0)
const spiralStartRadius = ref(10)
const spiralEndRadius = ref(50)
const spiralStartAltitude = ref(20)
const spiralEndAltitude = ref(100)
const spiralRevolutions = ref(3)
const spiralSegments = ref(60)

// Facade scan parameters
const facadeCenterX = ref(0)
const facadeCenterZ = ref(0)
const facadeWidth = ref(30)
const facadeHeight = ref(40)
const facadeScanDistance = ref(15)
const facadeOverlap = ref(30)
const facadeOrientation = ref(0)
const selectedFaces = ref(['North', 'East', 'South', 'West']) // Default: select all faces
const facadeOptions = [
  { title: 'North Face', value: 'North' },
  { title: 'East Face', value: 'East' },
  { title: 'South Face', value: 'South' },
  { title: 'West Face', value: 'West' }
]

// Add state for collapsible sections
const patternOptionsExpanded = ref(true);
const flightParamsExpanded = ref(true);
const objectInfoExpanded = ref(true);
const scanSettingsExpanded = ref(true);
const speedSettingsExpanded = ref(true);
const takeoffSectionExpanded = ref(true);
const cameraSettingsExpanded = ref(true);

// Add missing variables
const loopAnimation = ref(false);
const followCamera = ref(true);

// Camera and GSD Settings
const selectedDroneModel = ref('phantom4pro'); // Default to Phantom 4 Pro
const targetGSD = ref(2.5); // Default GSD target in cm/pixel
const frontOverlap = ref(75); // Default front overlap (%)
const sideOverlap = ref(65); // Default side overlap (%)
const photogrammetryParameters = ref(null);
const showGSDInfo = ref(false); // Controls GSD info dialog
const currentCamera = ref({
  name: '',
  focalLength: 0,
  sensorWidth: 0,
  sensorHeight: 0,
  imageWidth: 0,
  imageHeight: 0
});

// Toggle section visibility
const toggleSection = (section) => {
  if (section === 'patternOptions') patternOptionsExpanded.value = !patternOptionsExpanded.value;
  else if (section === 'flightParams') flightParamsExpanded.value = !flightParamsExpanded.value;
  else if (section === 'objectInfo') objectInfoExpanded.value = !objectInfoExpanded.value;
  else if (section === 'scanSettings') scanSettingsExpanded.value = !scanSettingsExpanded.value;
  else if (section === 'speedSettings') speedSettingsExpanded.value = !speedSettingsExpanded.value;
  else if (section === 'takeoffSettings') takeoffSectionExpanded.value = !takeoffSectionExpanded.value;
  else if (section === 'cameraSettings') cameraSettingsExpanded.value = !cameraSettingsExpanded.value;
};

// Computed property for available drone models
const availableDroneModels = computed(() => {
  // For photogrammetry missions, prioritize drones with better cameras
  if (pattern.value === 'grid' || pattern.value === 'lawnmower') {
    return droneModels.filter(drone => 
      drone.categories.includes('mapping') || 
      drone.categories.includes('professional')
    );
  }
  
  // For facade scans, prioritize drones with optical zoom
  if (pattern.value === 'facade') {
    return droneModels.filter(drone => 
      drone.camera.opticalZoom > 1 || 
      drone.categories.includes('inspection')
    );
  }
  
  // Return all drones for other mission types
  return droneModels;
});

// Format drone models for v-select
const droneModelOptions = computed(() => {
  return availableDroneModels.value.map(model => ({
    value: model.id,
    title: model.name,
    subtitle: model.camera.name,
    prependAvatar: model.camera.opticalZoom > 1 ? 'ðŸ“¸' : 'ðŸŽ¥',
    appendIcon: model.categories.includes('professional') ? 'mdi-shield-check' : '',
  }));
});

// Update pattern and params when altitude changes
watch(startingAltitude, () => {
  if (pattern.value && patternCalculated.value) {
    console.log('Altitude changed, recalculating pattern');
    calculatePattern();
  }

  // Recalculate GSD and other photogrammetry parameters when altitude changes
  if (currentCamera.value.focalLength) {
    recalculatePhotogrammetryParams();
  }
});

// Update camera parameters when drone model changes
const updateCameraFromDrone = () => {
  if (!selectedDroneModel.value) return;

  const drone = getDroneModel(selectedDroneModel.value);
  if (!drone || !drone.camera) {
    currentCamera.value = {
      name: 'Unknown',
      focalLength: 0,
      sensorWidth: 0,
      sensorHeight: 0,
      imageWidth: 0,
      imageHeight: 0,
      pixelSize: 0,
      aspectRatio: 0
    };
    return;
  }

  // Update camera specs with selected drone's camera
  currentCamera.value = { ...drone.camera };
  
  // Recalculate parameters with new camera
  recalculatePhotogrammetryParams();
};

// Watch for drone model changes
watch(selectedDroneModel, updateCameraFromDrone);

// Calculate altitude needed to achieve target GSD
const calculateAltitudeFromGSD = () => {
  if (!currentCamera.value.focalLength || !targetGSD.value) {
    return startingAltitude.value;
  }
  
  try {
    // Calculate altitude based on target GSD
    const newAltitude = calculateAltitudeForGSD({
      gsd: targetGSD.value, // in cm/pixel
      focalLength: currentCamera.value.focalLength,
      sensorWidth: currentCamera.value.sensorWidth,
      imageWidth: currentCamera.value.imageWidth
    });
    
    // Validate altitude is within reasonable range (5-500m)
    if (newAltitude < 5) {
      showNotification({
        message: 'Warning: Calculated altitude is very low. Consider increasing GSD.',
        color: 'warning',
        timeout: 5000
      });
      return 5; // Minimum reasonable altitude
    }
    
    if (newAltitude > 500) {
      showNotification({
        message: 'Warning: Calculated altitude is very high. Consider decreasing GSD.',
        color: 'warning',
        timeout: 5000
      });
      return 500; // Maximum reasonable altitude
    }
    
    return newAltitude;
  } catch (error) {
    console.error('Error calculating altitude from GSD:', error);
    return startingAltitude.value; // Return current altitude on error
  }
};

// Apply target GSD by adjusting altitude
const applyTargetGSD = () => {
  const newAltitude = calculateAltitudeFromGSD();
  
  // Update altitude if it's different
  if (Math.abs(startingAltitude.value - newAltitude) > 0.1) {
    startingAltitude.value = Math.round(newAltitude);
    
    showNotification({
      message: `Altitude adjusted to ${startingAltitude.value}m to achieve target GSD`,
      color: 'info',
      timeout: 3000
    });
    
    // Also recalculate flight pattern if it exists
    if (pattern.value && patternCalculated.value) {
      calculatePattern();
    }
  }
};

// Calculate all photogrammetry parameters based on current settings
const recalculatePhotogrammetryParams = () => {
  if (!currentCamera.value.focalLength) {
    photogrammetryParameters.value = null;
    return;
  }
  
  try {
    // Call the implementation method directly rather than passing parameters
    calculatePhotogrammetryParameters();
  } catch (error) {
    console.error('Error calculating photogrammetry parameters:', error);
    photogrammetryParameters.value = null;
  }
};

// Create refs to store event handlers at component level
const eventHandlers = ref({
  takeoffLocationSet: null,
  orbitTargetSelected: null
});

// Dragging functionality
const startDrag = (event) => {
  // Prevent dragging when clicking on the close button
  if (event.target.closest('.v-btn')) return
  
  // Add dragging class to both panel and body
  const panel = event.currentTarget.parentElement
  if (panel) {
    panel.classList.add('dragging')
  }
  
  // Add class to body to control 3D scene pointer events
  document.body.classList.add('panel-dragging')
  
  // Store initial mouse and panel positions
  const panelRect = panel.getBoundingClientRect()
  dragOffset.value = {
    x: event.clientX - panelRect.left,
    y: event.clientY - panelRect.top
  }
  
  // Start dragging after setting the offset
  isDragging.value = true
  
  // Add event listeners
  document.addEventListener('mousemove', handleDrag)
  document.addEventListener('mouseup', stopDrag)
}

// Handle drag movement
const handleDrag = (event) => {
  if (!isDragging.value) return
  
  // Get viewport dimensions
  const windowWidth = window.innerWidth
  const windowHeight = window.innerHeight
  
  // Get the panel element
  const panel = document.querySelector('.mission-simulation-panel')
  if (!panel) return
  
  // Get panel dimensions
  const panelWidth = panel.offsetWidth
  const panelHeight = panel.offsetHeight
  
  // Allow more flexibility: reduce padding to just 5px from edges
  const padding = 5
  
  // Calculate the new position based on mouse position and original offset
  let newX = event.clientX - dragOffset.value.x
  let newY = event.clientY - dragOffset.value.y
  
  // Less restrictive constraints - allow more of the panel to go off-screen if needed
  // Just ensure at least 100px of panel width remains visible within the viewport
  const minVisibleWidth = Math.min(100, panelWidth * 0.2)
  const minVisibleHeight = Math.min(50, panelHeight * 0.2)
  
  newX = Math.max(-panelWidth + minVisibleWidth, Math.min(windowWidth - minVisibleWidth, newX))
  newY = Math.max(padding, Math.min(windowHeight - minVisibleHeight, newY))
  
  // Direct DOM manipulation for smoother dragging
  panel.style.transform = 'none' // Remove any transform when manually positioning
  panel.style.top = `${newY}px`
  panel.style.left = `${newX}px`
  
  // Update position state for when dragging stops
  panelPosition.value = { x: newX, y: newY }
}

// Stop drag operation
const stopDrag = () => {
  if (!isDragging.value) return
  
  isDragging.value = false
  
  // Remove the dragging class from panel
  const panel = document.querySelector('.mission-simulation-panel')
  if (panel) {
    panel.classList.remove('dragging')
    
    // Store the current position in case styles get reset
    const currentStyles = {
      left: panel.style.left,
      top: panel.style.top,
      transform: 'none' // Ensure no transform is applied
    }
    
    // Apply the position with a small delay to ensure it sticks
    setTimeout(() => {
      Object.assign(panel.style, currentStyles)
    }, 5)
  }
  
  // Remove class from body
  document.body.classList.remove('panel-dragging')
  
  // Remove event listeners
  document.removeEventListener('mousemove', handleDrag)
  document.removeEventListener('mouseup', stopDrag)
}

// Close panel function
const closePanel = () => {
  isVisible.value = false
  missionStore.toggleSimulationPanel()
  emit('close')
}

// Clean up event listeners
onBeforeUnmount(() => {
  document.removeEventListener('mousemove', handleDrag)
  document.removeEventListener('mouseup', stopDrag)
})

// Set the pattern type
const setPattern = (newPattern) => {
  pattern.value = newPattern
  
  // Load default parameters based on pattern
  if (newPattern === 'building-scan') {
    buildingWidth.value = 100
    buildingLength.value = 300
    buildingHeight.value = 300
    scanDistance.value = 30
    overlap.value = 20
  } else if (newPattern === 'grid') {
    // Set grid defaults
  } else if (newPattern === 'spiral') {
    // Set spiral defaults
    spiralCenterX.value = 0
    spiralCenterZ.value = 0
    spiralStartRadius.value = 10
    spiralEndRadius.value = 50
    spiralStartAltitude.value = 20
    spiralEndAltitude.value = 100
    spiralRevolutions.value = 3
    spiralSegments.value = 60
  } else if (newPattern === 'orbit') {
    // Set orbit defaults
    orbitCenterX.value = 0
    orbitCenterZ.value = 0
    orbitRadius.value = 30
    orbitAltitude.value = 60
    orbitCameraMode.value = 'center'
    orbitCameraAngle.value = -45
    orbitSegments.value = 16
    orbitCount.value = 1
    orbitVerticalShift.value = 5
  } else if (newPattern === 'facade') {
    // Set facade scan defaults
    facadeCenterX.value = 0
    facadeCenterZ.value = 0
    facadeWidth.value = 30
    facadeHeight.value = 40
    facadeScanDistance.value = 15
    facadeOverlap.value = 30
    facadeOrientation.value = 0
  }
}

// Watch for mission type changes
watch(selectedMissionType, (newType) => {
  if (newType === 'building-scan') {
    patternType.value = '3d'
    pattern.value = 'building-scan'
  } else if (newType === 'terrain-mapping') {
    patternType.value = '2d'
    pattern.value = 'grid'
  } else if (newType === 'inspection') {
    patternType.value = '3d'
    pattern.value = 'orbit'
  }
})

// Calculate flight time based on waypoints and speed
const flightTimeDisplay = computed(() => {
  if (!simulationWaypoints.value.length) return '0:00'
  
  // Calculate distance between waypoints
  let totalDistance = 0
  for (let i = 1; i < simulationWaypoints.value.length; i++) {
    const prev = simulationWaypoints.value[i-1]
    const curr = simulationWaypoints.value[i]
    const dx = curr.x - prev.x
    const dy = curr.y - prev.y
    const dz = curr.z - prev.z
    totalDistance += Math.sqrt(dx*dx + dy*dy + dz*dz)
  }
  
  // Calculate time based on distance and speed (5ft/s * speed multiplier)
  const baseSpeed = 5 // ft/s
  const timeInSeconds = totalDistance / (baseSpeed * simulationSpeed.value)
  
  // Format as mm:ss
  const minutes = Math.floor(timeInSeconds / 60)
  const seconds = Math.floor(timeInSeconds % 60)
  return `${minutes}:${seconds.toString().padStart(2, '0')}`
})

// Calculate pattern
const calculatePattern = () => {
  // First check if takeoff location is set
  if (!hasTakeoffLocation.value) {
    showNotification({
      message: 'Please set a takeoff location first',
      color: 'error',
      timeout: 3000
    });
    takeoffSectionExpanded.value = true; // Expand takeoff section to draw attention
    return;
  }
  
  if (!pattern.value) {
    showNotification({
      message: 'Please select a pattern type',
      color: 'error',
      timeout: 3000
    });
    return;
  }

  // Set skipVisualization flag in the store to prevent BuildingVisualization from creating automatic objects
  if (missionStore.simulation) {
    missionStore.simulation.skipVisualization = true;
  } else {
    missionStore.simulation = {
      ...missionStore.simulation,
      skipVisualization: true
    };
  }

  // Reset existing waypoints
  clearWaypoints();
  
  try {
    // Create a base pattern data structure if it doesn't exist yet
    const initializePatternData = () => {
      if (!missionStore.patternData) {
        missionStore.patternData = {};
      }
      
      // Initialize pattern-specific data
      const patternType = pattern.value;
      if (!missionStore.patternData[patternType]) {
        missionStore.patternData[patternType] = {};
      }
      
      return missionStore.patternData[patternType];
    };
    
    // Get or initialize pattern data
    const patternData = initializePatternData();
    
    // Initialize building data for building-scan pattern if needed
    if (pattern.value === 'building-scan') {
      // Create/update building data
      if (!missionStore.patternData.building) {
        missionStore.patternData.building = {
          center: { 
            x: missionStore.takeoffLocation.lat, 
            y: 0, 
            z: missionStore.takeoffLocation.lng 
          },
          width: buildingWidth.value,
          depth: buildingLength.value,
          height: buildingHeight.value,
          orientation: 0
        };
      } else {
        // Update existing building data with form values
        missionStore.patternData.building.width = buildingWidth.value;
        missionStore.patternData.building.depth = buildingLength.value;
        missionStore.patternData.building.height = buildingHeight.value;
      }
      
      // Check if scan object exists first - don't automatically create one
      if (!scanObjectObj.value) {
        showNotification({
          message: 'Please create a building object first using the Create 3D Object button',
          color: 'error',
          timeout: 3000
        });
        return;
      }
      
      // For now, we're not generating waypoints for building scan
      // This will be implemented separately
      showNotification({
        message: 'Building scan pattern is currently being implemented',
        color: 'info',
        timeout: 3000
      });
      return;
    }
    
    // Get building data with safe defaults
    const {
      center = { 
        x: missionStore.takeoffLocation ? missionStore.takeoffLocation.lat : 0, 
        y: 0, 
        z: missionStore.takeoffLocation ? missionStore.takeoffLocation.lng : 0 
      },
      width = buildingWidth.value || 20,
      depth = buildingLength.value || 20,
      height = buildingHeight.value || 10,
      orientation = 0
    } = (missionStore.patternData?.building || {});
    
    let generatedWaypoints = [];
    const patternType = pattern.value;
    console.log(`Calculating pattern for type: ${patternType}`);
    
    // Initialize pattern parameters
    const startAltitude = Number(startingAltitude.value) || 30; 
    const missionSpeedValue = Number(missionSpeed.value) || 5;
    
    // Generate waypoints based on pattern type
    switch (patternType) {
      case 'building-scan':
        // Building scan pattern logic
        if (!missionStore.patternData.building) {
          showNotification({
            message: 'Please create a building object first',
            color: 'error',
            timeout: 3000
          });
          return;
        }
        
        // Use building scan logic from original code
        // This will be replaced with the new pattern generators in a future update
        break;
        
      case 'grid':
        // Grid pattern logic not yet implemented
        showNotification({
          message: 'Grid pattern is coming soon',
          color: 'info',
          timeout: 3000
        });
        return;
        
      case 'orbit':
        // Orbit pattern parameters
        const orbitRadius = Number(orbitRadius.value) || 20;
        const orbitAltitude = Number(orbitAltitude.value) || startAltitude;
        const segments = Number(orbitSegments.value) || 16;
        
        console.log('Orbit params:', { 
          center, 
          orbitRadius, 
          orbitAltitude, 
          segments 
        });

        // Generate orbit waypoints using the dedicated function
        generatedWaypoints = generateOrbitPath(
          center,
          orbitRadius,
          orbitAltitude,
          segments
        );
        
        // Calculate coverage area (simple circle)
        const circleArea = Math.PI * orbitRadius * orbitRadius;
        if (typeof missionStore.setPatternCoverageArea === 'function') {
          missionStore.setPatternCoverageArea(circleArea);
        } else {
          // Fallback
          coverageArea.value = circleArea;
        }
        break;
        
      case 'spiral':
        // Spiral pattern parameters
        const startRadius = Number(spiralStartRadius.value) || 10;
        const endRadius = Number(spiralEndRadius.value) || 50;
        const spiralAltitude = Number(spiralStartAltitude.value) || startAltitude;
        const revolutions = Number(spiralRevolutions.value) || 2;
        
        console.log('Spiral params:', { 
          center, 
          startRadius, 
          endRadius, 
          spiralAltitude, 
          revolutions 
        });

        // Generate spiral waypoints using the dedicated function
        generatedWaypoints = generateSpiralPath(
          center,
          startRadius,
          endRadius,
          spiralAltitude,
          revolutions
        );
        
        // Calculate coverage area (based on largest radius)
        const spiralArea = Math.PI * endRadius * endRadius;
        if (typeof missionStore.setPatternCoverageArea === 'function') {
          missionStore.setPatternCoverageArea(spiralArea);
    } else {
          // Fallback
          coverageArea.value = spiralArea;
        }
        break;
        
      case 'facade':
        // Facade scan parameters
        const scanDistance = Number(facadeScanDistance.value) || 5;
        const verticalOverlap = Number(facadeOverlap.value) || 20;
        
        console.log('Facade scan params:', { 
          center,
          width,
          height,
          orientation,
          scanDistance,
          verticalOverlap,
          selectedFaces: selectedFaces.value
        });
        
        // Calculate camera parameters for facade scan if camera settings are available
        let facadeParams = null;
        let verticalSpacing = height / 10; // Default value if GSD calculations are not available
        
        if (currentCamera.value.focalLength) {
          try {
            // Calculate facade-specific parameters using camera properties
            facadeParams = calculateFacadeParameters({
              altitude: startAltitude, // Not directly used for facades, but needed for the function
              focalLength: currentCamera.value.focalLength,
              sensorWidth: currentCamera.value.sensorWidth,
              sensorHeight: currentCamera.value.sensorHeight,
              imageWidth: currentCamera.value.imageWidth,
              imageHeight: currentCamera.value.imageHeight,
              distance: scanDistance,
              facadeWidth: width,
              facadeHeight: height,
              overlap: verticalOverlap
            });
            
            // Use the calculated vertical spacing for better image capture
            verticalSpacing = facadeParams.verticalSpacing;
            
            console.log('Calculated facade parameters:', facadeParams);
            
            // Show feedback about the effective parameters
            showNotification({
              message: `Optimized vertical spacing: ${verticalSpacing.toFixed(1)}m, Effective GSD: ${facadeParams.gsd.toFixed(1)} cm/px`,
              color: 'info',
              timeout: 4000
            });
          } catch (error) {
            console.error('Error calculating facade parameters:', error);
            // Fall back to default value if calculation fails
          }
        }
        
        // Check if scan object exists
        if (!scanObjectObj.value) {
          showNotification({
            message: 'Please create a building object first using the Create 3D Object button',
            color: 'error',
            timeout: 3000
          });
          return;
        }
        
        // Create building corners based on the center, width, height and orientation
        const halfWidth = width / 2;
        const halfDepth = depth / 2;
        const angleRad = (orientation * Math.PI) / 180;
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
        
        // Calculate the four corners of the building
        const cornerNW = {
          x: center.x - halfWidth * cos - halfDepth * sin,
          y: 0,
          z: center.z + halfWidth * sin - halfDepth * cos
        };
        
        const cornerNE = {
          x: center.x + halfWidth * cos - halfDepth * sin,
          y: 0,
          z: center.z - halfWidth * sin - halfDepth * cos
        };
        
        const cornerSE = {
          x: center.x + halfWidth * cos + halfDepth * sin,
          y: 0,
          z: center.z - halfWidth * sin + halfDepth * cos
        };
        
        const cornerSW = {
          x: center.x - halfWidth * cos + halfDepth * sin,
          y: 0,
          z: center.z + halfWidth * sin + halfDepth * cos
        };
        
        // Map corners to cardinal directions (North, East, South, West)
        const faceCorners = [
          [cornerNW, cornerNE], // North face (0)
          [cornerNE, cornerSE], // East face (1)
          [cornerSE, cornerSW], // South face (2)
          [cornerSW, cornerNW]  // West face (3)
        ];
        
        // Filter corners based on selected faces
        const filteredCorners = [];
        const faceDirections = ['North', 'East', 'South', 'West'];
        
        // Convert selectedFaces to indices if it contains string values
        let selectedFaceIndices = selectedFaces.value.map(face => {
          if (typeof face === 'string') {
            return faceDirections.indexOf(face);
          }
          return face;
        }).filter(index => index >= 0);
        
        // Default to all faces if none selected
        if (selectedFaceIndices.length === 0) {
          selectedFaceIndices = [0, 1, 2, 3];
        }
        
        // Add corners for each selected face
        selectedFaceIndices.forEach(faceIndex => {
          if (faceIndex >= 0 && faceIndex < 4) {
            const [start, end] = faceCorners[faceIndex];
            filteredCorners.push(start);
            filteredCorners.push(end);
          }
        });
        
        // Generate waypoints only for selected faces
        if (filteredCorners.length > 0) {
          generatedWaypoints = generateFacadeScanPath(
            filteredCorners,
            height,
            scanDistance,
            verticalSpacing, // Using calculated spacing instead of percentage
            startAltitude,
            true // Use absolute spacing instead of percentage
          );
        } else {
          // Fallback to original implementation if no corners were selected
          // Adjust the overlap parameter based on calculation
          const adjustedOverlap = facadeParams ? facadeParams.overlap : verticalOverlap;
          
          generatedWaypoints = flightPatternFacadeScan(
            center,
            width,
            height,
            scanDistance,
            adjustedOverlap,
            orientation,
            facadeParams ? true : false // Use absolute spacing if we have facadeParams
          );
        }
        
        // Calculate coverage area (rectangular approximation of selected facades)
        const perimeterLength = selectedFaceIndices.length === 4 ? 
          2 * (width + depth) : 
          selectedFaceIndices.length * (selectedFaceIndices.includes(0) || selectedFaceIndices.includes(2) ? width : depth);
        const facadeArea = perimeterLength * height;
        if (typeof missionStore.setPatternCoverageArea === 'function') {
          missionStore.setPatternCoverageArea(facadeArea);
        } else {
          // Fallback
          coverageArea.value = facadeArea;
        }
        break;
        
      default:
        showNotification({
          message: `Pattern type '${patternType}' not implemented yet`,
          color: 'warning',
          timeout: 3000
        });
        return;
    }
    
    console.log(`Generated ${generatedWaypoints.length} waypoints for pattern type ${patternType}`);
    
    // Validate generated waypoints
    if (!generatedWaypoints || generatedWaypoints.length === 0) {
      throw new Error(`No waypoints generated for pattern type: ${patternType}`);
    }
    
    // Convert pattern waypoints to mission waypoints
    const missionWaypoints = convertToMissionWaypoints(generatedWaypoints, {
      startPosition: { 
        x: missionStore.originCoordinates.latitude, 
        y: 0, 
        z: missionStore.originCoordinates.longitude 
      },
      includeTakeoff: true,
      includeReturn: true,
      initialAltitude: startAltitude,
      maxTransitSpeed: Number(missionStore.flightParameters.transitSpeed) || 10,
      missionSpeed: missionSpeedValue
    });
    
    // Set waypoints in the store
    if (typeof missionStore.setWaypoints === 'function') {
      missionStore.setWaypoints(missionWaypoints);
    } else {
      // Fallback
      missionStore.waypoints = [...missionWaypoints];
      if (missionStore.simulation) {
        missionStore.simulation.waypoints = [...missionWaypoints];
      }
    }
    simulationWaypoints.value = [...missionWaypoints];
    
    // Reset animation state
    currentWaypointIndex.value = 0;
    animationProgress.value = 0;
    
    // Set initial drone position
    if (missionWaypoints.length > 0) {
      setDronePosition({
        x: missionWaypoints[0].x,
        y: missionWaypoints[0].y,
        z: missionWaypoints[0].z,
        followCamera: true
      });
    }
    
    console.log(`Pattern calculation complete. Total waypoints: ${missionWaypoints.length}`);
  patternCalculated.value = true;
  
    // Show success notification
    showNotification({
      message: `${patternType} pattern calculated with ${missionWaypoints.length} waypoints`,
      color: 'success',
      timeout: 3000
    });
    
  } catch (error) {
    console.error('Error calculating pattern:', error);
    patternCalculated.value = false;
    
    showNotification({
      message: `Error calculating pattern: ${error.message}`,
      color: 'error',
      timeout: 5000
    });
  }
};

// Toggle animation
const toggleAnimation = () => {
  if (isPlaying.value) {
    // Pause animation
    if (animationTimer.value) {
      clearInterval(animationTimer.value)
      animationTimer.value = null
    }
    isPlaying.value = false
    toggleSimulationPlayState(false)
  } else {
    // Start/resume animation
    startAnimation()
  }
}

// Start animation
const startAnimation = () => {
  if (!patternCalculated.value || !simulationWaypoints.value || simulationWaypoints.value.length === 0) {
    showNotification({
      message: 'Please calculate a pattern first',
      color: 'error',
      timeout: 3000
    });
    return;
  }
  
  // Check if takeoff location is set
  if (!missionStore.hasTakeoffLocation) {
    showTakeoffLocationPrompt();
    return;
  }
  
  try {
  isPlaying.value = true;
    toggleSimulationPlayState(true);
    
    // Check for valid waypoints before starting animation
    if (!validateWaypoints(simulationWaypoints.value)) {
      throw new Error('Invalid waypoint data detected');
    }
    
    // If animation was paused, resume from current position
  if (animationTimer.value) {
    clearInterval(animationTimer.value);
  }
  
    const updateInterval = 50; // 50ms per update (20 updates per second)
  animationTimer.value = setInterval(() => {
      // Safe guard against empty or invalid waypoints
      if (!simulationWaypoints.value || simulationWaypoints.value.length < 2) {
        console.error('No valid waypoints to animate');
        clearInterval(animationTimer.value);
        animationTimer.value = null;
        isPlaying.value = false;
        toggleSimulationPlayState(false);
        return;
      }
      
      try {
        // Update animation progress
        animationProgress.value += simulationSpeed.value * updateInterval / 1000;
        
        // Check if we've reached the next waypoint
        if (animationProgress.value >= 1) {
          animationProgress.value = 0;
      currentWaypointIndex.value++;
          
          // If we've reached the end, reset or stop
          if (currentWaypointIndex.value >= simulationWaypoints.value.length - 1) {
            if (loopAnimation.value) {
              currentWaypointIndex.value = 0;
            } else {
              // Stop animation
              clearInterval(animationTimer.value);
              animationTimer.value = null;
              isPlaying.value = false;
              toggleSimulationPlayState(false);
              return;
            }
          }
      
      // Update active waypoint in store
          setActiveWaypoint(currentWaypointIndex.value);
        }
        
        // Calculate interpolated position
        const currentWaypoint = simulationWaypoints.value[currentWaypointIndex.value];
        const nextWaypoint = simulationWaypoints.value[currentWaypointIndex.value + 1];
        
        // Safely access coordinates with fallbacks
        const current = {
          x: getCoordinate(currentWaypoint, 'x', 'lat'),
          y: getCoordinate(currentWaypoint, 'y', 'height'),
          z: getCoordinate(currentWaypoint, 'z', 'lng')
        };
        
        const next = {
          x: getCoordinate(nextWaypoint, 'x', 'lat'),
          y: getCoordinate(nextWaypoint, 'y', 'height'),
          z: getCoordinate(nextWaypoint, 'z', 'lng')
        };
        
        // Linear interpolation between current and next waypoint
        const interpolatedPosition = {
          x: current.x + (next.x - current.x) * animationProgress.value,
          y: current.y + (next.y - current.y) * animationProgress.value,
          z: current.z + (next.z - current.z) * animationProgress.value
        };
        
        // Update drone position in store
        setDronePosition({
          x: interpolatedPosition.x,
          y: interpolatedPosition.y,
          z: interpolatedPosition.z,
          followCamera: followCamera.value
        });
      } catch (err) {
        console.error('Error in animation update:', err);
      clearInterval(animationTimer.value);
        animationTimer.value = null;
        isPlaying.value = false;
        toggleSimulationPlayState(false);
        
        showNotification({
          message: 'Animation error: ' + err.message,
          color: 'error',
          timeout: 5000
        });
      }
    }, updateInterval);
  } catch (error) {
    console.error('Error starting animation:', error);
    isPlaying.value = false;
    toggleSimulationPlayState(false);
    
    showNotification({
      message: 'Error starting animation: ' + error.message,
      color: 'error',
      timeout: 5000
    });
  }
}

// Validates waypoints to ensure they have necessary properties
const validateWaypoints = (waypoints) => {
  if (!waypoints || !Array.isArray(waypoints) || waypoints.length < 2) {
    return false;
  }
  
  // Check first few waypoints
  for (let i = 0; i < Math.min(waypoints.length, 3); i++) {
    const wp = waypoints[i];
    if (!wp) return false;
    
    // Check for position data in any of the supported formats
    if ((!wp.x && wp.x !== 0) && (!wp.position?.lat && wp.position?.lat !== 0)) {
      console.error('Invalid waypoint structure:', wp);
      return false;
    }
  }
  
  return true;
};

// Helper function to safely get coordinates from waypoints
const getCoordinate = (waypoint, primary, fallback) => {
  if (!waypoint) return 0;
  
  // First try direct property (x, y, z)
  if (waypoint[primary] !== undefined) return waypoint[primary];
  
  // Then try position property (position.lat, position.height, position.lng)
  if (waypoint.position && waypoint.position[fallback] !== undefined) {
    return waypoint.position[fallback];
  }
  
  // If all else fails, return 0
  return 0;
};

// Initialize with a default pattern on mount
onMounted(async () => {
  try {
    // Add global error handler to help debug issues
    window.addEventListener('error', (event) => {
      console.error('Global error caught:', event.error);
    });
    
  // Set initial panel position
  adjustInitialPosition();
  
  // Load flight parameters from store
  const storeFlightParams = missionStore.flightParameters;
  if (storeFlightParams) {
    climbSpeed.value = storeFlightParams.climbSpeed;
    startingAltitude.value = storeFlightParams.startingAltitude;
    missionSpeed.value = storeFlightParams.missionSpeed;
    transitSpeed.value = storeFlightParams.transitSpeed;
  }
  
  // Load safety settings
  const storeSafetySettings = missionStore.safetySettings;
  if (storeSafetySettings) {
    returnToHome.value = storeSafetySettings.returnToHome;
    lossOfCommsBehavior.value = storeSafetySettings.lossOfCommsBehavior;
  }
    
    // Initialize camera settings with default drone model
    if (droneModels && droneModels.length > 0) {
      selectedDroneModel.value = droneModels[0].id;
      updateCameraFromDrone();
      
      // Initialize gsd calculation with current altitude
      setTimeout(() => {
        recalculatePhotogrammetryParams();
      }, 300);
  }

  // Check if takeoff location is set using the store getter
  if (!missionStore.hasTakeoffLocation) {
    console.log('No take-off location found, showing prompt');
    // Show prompt to set takeoff location
    showTakeoffLocationPrompt();
  } else {
    console.log('Existing take-off location found:', missionStore.takeoffLocation);
  }
  
    // Use safer event handling with proper cleanup
    const handleTakeoffSet = (event) => {
      // Takeoff location has been set
      console.log('Takeoff location set event received');
      
      // Close the prompt if it's open
      if (takeoffPromptVisible.value) {
        takeoffPromptVisible.value = false;
      }
      
      // Show success message
      showNotification({
        message: 'Takeoff location set successfully',
        color: 'success',
        timeout: 3000
      });
      
      // Remove automatic pattern calculation
      // setTimeout(() => {
      //   if (!patternCalculated.value && pattern.value) {
      //     calculatePattern();
      //   }
      // }, 500);
    };
    
    const handleOrbitTargetSelected = (event) => {
      // Update the orbit center coordinates with the selected point
      if (event.detail) {
        orbitCenterX.value = event.detail.x;
        orbitCenterZ.value = event.detail.z;
        
        // No longer automatically generate the orbit pattern
        // Let the user manually create patterns
        // if (pattern.value === 'orbit') {
        //   calculatePattern();
        // }
      }
    };
    
    // Store the handler functions for later cleanup
    eventHandlers.value.takeoffLocationSet = handleTakeoffSet;
    eventHandlers.value.orbitTargetSelected = handleOrbitTargetSelected;
    
    // Store the handlers in component state instead of the store
    // This avoids relying on the store methods that might not exist
    window.addEventListener('takeoff-location-set', eventHandlers.value.takeoffLocationSet);
    window.addEventListener('orbit-target-selected', eventHandlers.value.orbitTargetSelected);
  
  // Check if there are already simulation waypoints in the store
    const storeWaypoints = missionStore.simulation?.waypoints;
  
  if (storeWaypoints && storeWaypoints.length > 0) {
      simulationWaypoints.value = storeWaypoints;
      patternCalculated.value = true;
      currentWaypointIndex.value = missionStore.simulation.activeWaypoint || 0;
      animationProgress.value = (currentWaypointIndex.value / (simulationWaypoints.value.length - 1)) * 100;
  } else {
    // Don't initialize with default building scan - wait for user to select pattern
    console.log('No waypoints found in store, waiting for user to select pattern and parameters');
    // Don't set default pattern 
    // setPattern('building-scan');
    // Don't auto-calculate pattern
    // setTimeout(() => {
    //  try {
    //    calculatePattern();
    //  } catch (err) {
    //    console.error('Error initializing pattern:', err);
    //    showNotification({
    //      message: `Error initializing pattern: ${err.message}`,
    //      color: 'error',
    //      timeout: 5000
    //    });
    //  }
    // }, 500);
  }
  } catch (error) {
    console.error('Error in component initialization:', error);
    showNotification({
      message: 'Error initializing mission simulation panel',
      color: 'error',
      timeout: 3000
    });
  }
  
  // Run hooks
  onMounted(() => {
    // Add event listener for drag start
    if (panel.value) {
      const header = panel.value.querySelector('.header');
      if (header) {
        header.addEventListener('mousedown', startDrag);
      }
    }
    
    // Add event listener for scan object creation
    window.addEventListener('scan-object-created', (event) => {
      if (event.detail && event.detail.object) {
        scanObjectObj.value = event.detail.object;
        console.log('Stored reference to scan object:', scanObjectObj.value);
      }
    });
  });
});

// Adjust the initial position of the panel
function adjustInitialPosition() {
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;
  
  // Position panel at center-top of viewport
  panelPosition.value = { 
    top: `10vh`, 
    left: `50%`, 
    transform: 'translateX(-50%)'
  };
}

// Handle drag movement
function handleMouseMove(event) {
  if (!isDragging.value) return;
  
  // Get viewport dimensions
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;
  
  // Get panel element
  const panel = document.querySelector('.mission-simulation-panel');
  if (!panel) return;
  
  // Calculate new position
  let left = event.clientX - dragOffset.value.x;
  let top = event.clientY - dragOffset.value.y;
  
  // Convert to percentages for responsive positioning
  const leftPercent = (left / windowWidth) * 100;
  const topPercent = (top / windowHeight) * 100;
  
  // Update panel position
  panelPosition.value = {
    top: `${topPercent}vh`,
    left: `${leftPercent}vw`,
    transform: 'none' // Remove the translate transform when dragging
  };
}

// Stop dragging
function handleMouseUp() {
  // Remove dragging class from panel and body
  const panel = document.querySelector('.mission-simulation-panel');
  if (panel) {
    panel.classList.remove('dragging');
  }
  
  // Remove class from body
  document.body.classList.remove('panel-dragging');
  
  // Stop dragging
  isDragging.value = false;
}

// Computed style for panel positioning
const panelStyle = computed(() => {
  return {
    top: panelPosition.value.top,
    left: panelPosition.value.left,
    transform: panelPosition.value.transform
  };
});

// Show prompt for takeoff location
const showTakeoffLocationPrompt = () => {
  showNotification({
    message: 'Please set a takeoff location first',
    color: 'warning',
    timeout: 3000
  });
};

// Handle takeoff location selection
const selectTakeoffLocation = () => {
  // Dispatch custom event to enter takeoff selection mode
  window.dispatchEvent(new CustomEvent('enter-takeoff-selection'))
  
  // Close the prompt - it will be handled by the ground click handler
  takeoffPromptVisible.value = false
}

// Clean up on component unmount
onBeforeUnmount(() => {
  try {
  if (animationTimer.value) {
      clearInterval(animationTimer.value);
      animationTimer.value = null;
    }
    
    // Remove event listeners using the local handlers
    window.removeEventListener('takeoff-location-set', eventHandlers.value.takeoffLocationSet);
    window.removeEventListener('orbit-target-selected', eventHandlers.value.orbitTargetSelected);
  } catch (error) {
    console.error('Error cleaning up component:', error);
  }
});

// Save flight parameters to store
const saveFlightParameters = () => {
  // Update flight parameters in store
  missionStore.updateFlightParameters({
    climbSpeed: climbSpeed.value,
    startingAltitude: startingAltitude.value,
    missionSpeed: missionSpeed.value,
    transitSpeed: transitSpeed.value
  });
  
  // Update safety settings in store
  missionStore.updateSafetySettings({
    returnToHome: returnToHome.value,
    lossOfCommsBehavior: lossOfCommsBehavior.value
  });
  
  // Show success notification
  showSuccessNotification('Flight parameters saved successfully');
}

// Add new function to select orbit target
const selectOrbitTarget = () => {
  // First check if takeoff location is set
  if (!missionStore.hasTakeoffLocation) {
    showTakeoffLocationPrompt();
    return;
  }
  
  console.log('Entering orbit target selection mode');
  
  // Dispatch custom event to enter orbit target selection mode
  window.dispatchEvent(new CustomEvent('enter-orbit-target-selection'));
}

// Helper function to safely access mission store methods
const safeStoreCall = (methodName, ...args) => {
  if (typeof missionStore[methodName] === 'function') {
    return missionStore[methodName](...args);
  } else {
    console.warn(`Missing mission store method: ${methodName}`);
    return null;
  }
};

// Use a safe version when clearing waypoints
const clearWaypoints = () => {
  if (typeof missionStore.clearWaypoints === 'function') {
    missionStore.clearWaypoints();
  } else {
    // Fallback: directly set empty waypoints if method doesn't exist
    missionStore.waypoints = [];
    if (missionStore.simulation) {
      missionStore.simulation.waypoints = [];
    }
  }
};

// Safe method to set active waypoint
const setActiveWaypoint = (index) => {
  if (typeof missionStore.setActiveWaypoint === 'function') {
    missionStore.setActiveWaypoint(index);
  } else if (missionStore.simulation) {
    missionStore.simulation.activeWaypoint = index;
  }
};

// Safe method to set drone position
const setDronePosition = (position) => {
  if (typeof missionStore.setDronePosition === 'function') {
    missionStore.setDronePosition(position);
  } else {
    missionStore.dronePosition = {
      ...missionStore.dronePosition,
      ...position
    };
  }
};

// Safe method to toggle simulation play state
const toggleSimulationPlayState = (isPlaying) => {
  if (typeof missionStore.toggleSimulationPlayState === 'function') {
    missionStore.toggleSimulationPlayState(isPlaying);
  } else if (missionStore.simulation) {
    missionStore.simulation.isPlaying = isPlaying;
  }
};

// Computed property to determine if takeoff location is set
const hasTakeoffLocation = computed(() => {
  return missionStore.hasTakeoffLocation;
});

// Format coordinate to display nicely
const formatCoordinate = (value) => {
  if (value === undefined || value === null) return 'N/A';
  return typeof value === 'number' ? value.toFixed(6) : value;
};

// Toggle face selection in the visual selector
const toggleFaceSelection = (face) => {
  const index = selectedFaces.value.indexOf(face);
  if (index >= 0) {
    // Remove face if already selected
    selectedFaces.value.splice(index, 1);
  } else {
    // Add face if not selected
    selectedFaces.value.push(face);
  }
};
const minVisiblePx = 100; // Minimum pixels that must remain visible
const minVisiblePercent = 0.2; // Or minimum percentage of element width
const scanObjectObj = ref(null); // Reference to the scan object

// Listen for scan object creation
window.addEventListener('scan-object-created', (event) => {
  if (event.detail && event.detail.object) {
    scanObjectObj.value = event.detail.object;
    console.log('Stored reference to scan object:', scanObjectObj.value);
  }
});

// Create a new 3D object
const createScanObject = () => {
  // First check if takeoff location is set
  if (!hasTakeoffLocation.value) {
    showNotification({
      message: 'Please set a takeoff location first',
      color: 'error',
      timeout: 3000
    });
    return;
  }
  
  console.log('Creating new 3D object with dimensions:', { 
    width: buildingWidth.value, 
    length: buildingLength.value, 
    height: buildingHeight.value 
  });
  
  // Set skipVisualization flag in the store to prevent automatic creation of objects by BuildingVisualization
  if (missionStore.simulation) {
    missionStore.simulation.skipVisualization = true;
  } else {
    missionStore.simulation = {
      ...missionStore.simulation,
      skipVisualization: true
    };
  }
  
  // Create a visualization of the building
  window.dispatchEvent(new CustomEvent('create-scan-object', {
    detail: {
      width: buildingWidth.value,
      length: buildingLength.value,
      height: buildingHeight.value,
      color: objectColor.value,
      position: {
        x: missionStore.takeoffLocation.lat,
        y: 0, // Ground level
        z: missionStore.takeoffLocation.lng
      },
      createGroundPlane: false, // Prevent ground plane creation
      createSecondaryObject: false, // Prevent secondary object creation
      opacity: 1.0, // Make it solid with no transparency
      showWireframe: false, // No wireframe
      centerInScene: false, // Don't recenter scene
      isDraggable: true // Enable drag and drop
    }
  }));
  
  showNotification({
    message: 'Building object created',
    color: 'success',
    timeout: 3000
  });
};

// Load hardware details from store
function loadHardwareFromStore() {
  console.log('Loading hardware from store:', missionStore.hardware);
  
  if (missionStore.hardware) {
    // Set drone model
    if (missionStore.hardware.drone) {
      selectedDroneModel.value = missionStore.hardware.drone;
    }
    
    // Set camera details if available
    if (missionStore.hardware.cameraDetails) {
      currentCamera.value = {
        name: `${missionStore.hardware.cameraDetails.brand} ${missionStore.hardware.cameraDetails.model}`,
        imageWidth: missionStore.hardware.cameraDetails.imageWidth || 0,
        imageHeight: missionStore.hardware.cameraDetails.imageHeight || 0,
        sensorWidth: missionStore.hardware.cameraDetails.sensorWidth || 0,
        sensorHeight: missionStore.hardware.cameraDetails.sensorHeight || 0,
        focalLength: Array.isArray(missionStore.hardware.lensDetails?.focalLength) 
          ? (missionStore.hardware.lensDetails.focalLength[0] + missionStore.hardware.lensDetails.focalLength[1]) / 2
          : (missionStore.hardware.lensDetails?.focalLength || 0)
      };
      
      // Log loaded camera details for debugging
      console.log('Loaded camera:', currentCamera.value);
      
      // Calculate initial GSD based on camera parameters and altitude
      calculateInitialGSDFromCamera();
    } else {
      console.log('No camera details found in store, using drone default');
      updateCameraFromDrone();
    }
    
    // Set mission parameters from flight parameters if available
    if (missionStore.flightParameters) {
      missionSpeed.value = missionStore.flightParameters.missionSpeed || 5;
    }
    
    // Set overlap parameters if stored
    if (missionStore.hardware.overlaps) {
      frontOverlap.value = missionStore.hardware.overlaps.front || 75;
      sideOverlap.value = missionStore.hardware.overlaps.side || 65;
    }
    
    // Load target GSD if available
    if (missionStore.hardware.targetGSD) {
      targetGSD.value = missionStore.hardware.targetGSD;
    }

    // Calculate photogrammetry parameters immediately
    calculatePhotogrammetryParameters();
  }
}

// Watch for changes in isVisible prop
watch(() => isVisible.value, (visible) => {
  if (visible) {
    console.log('Mission Simulation panel became visible');
    
    // Load hardware configuration when panel becomes visible
    nextTick(() => {
      loadHardwareFromStore();
      
      // Apply camera settings to visualization after a short delay to ensure DOM is updated
      setTimeout(() => {
        applyCameraToSimulation();
      }, 100);
    });
  }
}, { immediate: true });

// Calculate initial GSD based on loaded camera parameters
function calculateInitialGSDFromCamera() {
  if (!currentCamera.value) return;
  
  // Get default flight altitude from store or use reasonable default
  const altitude = missionStore.flightParameters?.altitude || 50;
  
  // Make sure we have all required parameters
  if (currentCamera.value.sensorWidth && 
      currentCamera.value.imageWidth && 
      currentCamera.value.focalLength) {
    
    // GSD (cm/pixel) = (sensor width * altitude * 100) / (focal length * image width)
    const gsd = (currentCamera.value.sensorWidth * altitude * 100) / 
                (currentCamera.value.focalLength * currentCamera.value.imageWidth);
    
    targetGSD.value = parseFloat(gsd.toFixed(2));
    console.log(`Initial GSD calculated: ${targetGSD.value} cm/pixel at altitude ${altitude}m`);
  }
}

// Watch for direct changes to mission store hardware
watch(() => missionStore.hardware, (newHardware) => {
  if (newHardware) {
    console.log('Hardware in store changed, reloading');
    loadHardwareFromStore();
  }
}, { deep: true });

// Watch for camera changes to update visualization
watch([() => currentCamera.value, () => photogrammetryParameters.value], () => {
  if (currentCamera.value?.focalLength && photogrammetryParameters.value) {
    console.log('Camera or photogrammetry parameters changed, updating visualization');
    applyCameraToSimulation();
  }
}, { deep: true });

// Component lifecycle hooks
onMounted(() => {
  console.log('Mission Simulation component mounted');
  
  // Load hardware configuration on component mount
  loadHardwareFromStore();
  
  // Adjust initial position
  adjustInitialPosition();
  
  // Add document-level event listeners
  document.addEventListener('mousemove', handleMouseMove);
  document.addEventListener('mouseup', handleMouseUp);
  
  // Add window resize listener
  window.addEventListener('resize', adjustInitialPosition);
  
  // Apply camera to simulation
  nextTick(() => {
    applyCameraToSimulation();
  });
  
  console.log('Mission Simulation panel mounted, hardware loaded:', missionStore.hardware);
});

onBeforeUnmount(() => {
  // Clean up animation timer
  if (animationTimer.value) {
    clearInterval(animationTimer.value);
  }
  
  // Remove event listeners
  document.removeEventListener('mousemove', handleMouseMove);
  document.removeEventListener('mouseup', handleMouseUp);
  window.removeEventListener('resize', adjustInitialPosition);
});

// Apply camera changes to 3D visualization
function applyCameraToSimulation() {
  if (!currentCamera.value) {
    console.log('No camera to apply to simulation');
    return;
  }
  
  const cameraInfo = {
    name: currentCamera.value.name,
    imageWidth: currentCamera.value.imageWidth,
    imageHeight: currentCamera.value.imageHeight,
    sensorWidth: currentCamera.value.sensorWidth,
    sensorHeight: currentCamera.value.sensorHeight,
    focalLength: currentCamera.value.focalLength,
    gsd: photogrammetryParameters.value?.gsd || targetGSD.value || 2.5,
    footprint: photogrammetryParameters.value?.footprint || { width: 50, height: 40 }
  };
  
  console.log('Applying camera to simulation:', cameraInfo);
  
  // Dispatch event to update camera in 3D scene
  window.dispatchEvent(new CustomEvent('update-camera-visualization', {
    detail: cameraInfo
  }));
}


// Sample drone models for the dropdown
const droneModels = [
  {
    id: 'freefly-astro',
    name: 'Freefly Astro',
    categories: ['professional', 'inspection'],
    camera: {
      name: 'Phase One iXM-100',
      imageWidth: 11608,
      imageHeight: 8708,
      sensorWidth: 53.4,
      sensorHeight: 40.0,
      focalLength: 80,
      opticalZoom: 1
    }
  },
  {
    id: 'dji-mavic-2-pro',
    name: 'DJI Mavic 2 Pro',
    categories: ['consumer', 'mapping'],
    camera: {
      name: 'Hasselblad L1D-20c',
      imageWidth: 5472,
      imageHeight: 3648,
      sensorWidth: 13.2,
      sensorHeight: 8.8,
      focalLength: 28,
      opticalZoom: 1
    }
  },
  {
    id: 'dji-phantom-4-pro',
    name: 'DJI Phantom 4 Pro',
    categories: ['prosumer', 'mapping'],
    camera: {
      name: 'DJI 1" CMOS',
      imageWidth: 5472,
      imageHeight: 3648,
      sensorWidth: 13.2,
      sensorHeight: 8.8,
      focalLength: 24,
      opticalZoom: 1
    }
  },
  {
    id: 'dji-matrice-300',
    name: 'DJI Matrice 300 RTK',
    categories: ['professional', 'inspection'],
    camera: {
      name: 'Zenmuse H20T',
      imageWidth: 5184,
      imageHeight: 3888,
      sensorWidth: 17.3,
      sensorHeight: 13.0,
      focalLength: 50,
      opticalZoom: 30
    }
  }
];

// Function to get drone model by ID
function getDroneModel(id) {
  return droneModels.find(model => model.id === id) || null;
}

// Calculate photogrammetry parameters
function calculatePhotogrammetryParameters() {
  if (!currentCamera.value) return;
  
  // Get flight altitude
  const altitude = missionStore.flightParameters?.altitude || startingAltitude.value || 50;
  
  // Calculate GSD in cm/pixel
  const gsd = (currentCamera.value.sensorWidth * altitude * 100) / 
              (currentCamera.value.focalLength * currentCamera.value.imageWidth);
  
  // Calculate footprint dimensions (m)
  const footprintWidth = (currentCamera.value.sensorWidth * altitude) / currentCamera.value.focalLength;
  const footprintHeight = (currentCamera.value.sensorHeight * altitude) / currentCamera.value.focalLength;
  
  // Calculate image spacing based on forward overlap (m)
  const imageSpacing = footprintWidth * (1 - frontOverlap.value / 100);
  
  // Calculate track spacing based on side overlap (m)
  const trackSpacing = footprintHeight * (1 - sideOverlap.value / 100);
  
  // Calculate area coverage per image (mÂ²)
  const areaCoverage = footprintWidth * footprintHeight;
  
  // Calculate effective area coverage considering overlap (mÂ²)
  const effectiveAreaCoverage = imageSpacing * trackSpacing;
  
  // Calculate images per hectare (10,000 mÂ²)
  const imagesPerHectare = 10000 / effectiveAreaCoverage;
  
  // Set the photogrammetry parameters
  photogrammetryParameters.value = {
    gsd,
    footprint: {
      width: footprintWidth,
      height: footprintHeight
    },
    imageSpacing,
    trackSpacing,
    areaCoverage,
    effectiveAreaCoverage,
    imagesPerHectare
  };
  
  console.log('Calculated photogrammetry parameters:', photogrammetryParameters.value);
  
  return photogrammetryParameters.value;
}

// Save the updated photogrammetry parameters to the store
function updatePhotogrammetryParameters() {
  if (!photogrammetryParameters.value) {
    calculatePhotogrammetryParameters();
  }
  
  if (!photogrammetryParameters.value) {
    showNotification({
      message: 'Unable to calculate photogrammetry parameters. Please check camera settings.',
      color: 'error',
      timeout: 3000
    });
    return;
  }
  
  // Get flight altitude
  const altitude = missionStore.flightParameters?.altitude || startingAltitude.value || 50;
  
  // Save camera and GSD parameters to store
  missionStore.setHardware({
    ...missionStore.hardware,
    drone: selectedDroneModel.value,
    targetGSD: targetGSD.value,
    overlaps: {
      front: frontOverlap.value,
      side: sideOverlap.value
    },
    photogrammetryParams: {
      ...photogrammetryParameters.value,
      altitude
    }
  });
  
  // Update flight parameters
  missionStore.updateFlightParameters({
    ...missionStore.flightParameters,
    altitude: altitude
  });
  
  // Update scene with new parameters
  dispatchPhotogrammetryParametersToScene();
  
  // Show success notification
  showNotification({
    message: 'Photogrammetry parameters updated',
    color: 'success',
    timeout: 3000
  });
}

// Dispatch photogrammetry parameters to scene
function dispatchPhotogrammetryParametersToScene() {
  if (!photogrammetryParameters.value) return;
  
  window.dispatchEvent(new CustomEvent('update-photogrammetry-parameters', {
    detail: {
      gsd: photogrammetryParameters.value.gsd,
      footprint: photogrammetryParameters.value.footprint,
      imageSpacing: photogrammetryParameters.value.imageSpacing,
      trackSpacing: photogrammetryParameters.value.trackSpacing,
      frontOverlap: frontOverlap.value,
      sideOverlap: sideOverlap.value,
      altitude: missionStore.flightParameters?.altitude || startingAltitude.value || 50
    }
  }));
  
  console.log('Dispatched photogrammetry parameters to scene');
}

// Add reference to the new expanded state
const hardwareInfoExpanded = ref(true);

// Add function to navigate to hardware selection
const navigateToHardwareSelection = () => {
  // Change workflow step in mission store
  missionStore.workflowStep = 'hardware';
  
  // Dispatch event to show hardware selection panel
  window.dispatchEvent(new CustomEvent('show-hardware-selection'));
  
  // Close current panel
  closePanel();
};
</script>

<style scoped>
.mission-simulation-panel {
  position: fixed !important;
  z-index: 9999; 
  width: 80%;
  max-width: 800px;
  max-height: 90vh; /* Limit to 90% of viewport height */
  background-color: rgba(0, 0, 0, 0.95);
  border-radius: 8px;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.7);
  color: white;
  overflow: auto; /* Allow scrolling */
  display: flex;
  flex-direction: column;
  border: 1px solid rgba(255, 193, 7, 0.2);
  margin: 0;
  padding: 0;
  transition: transform 0.3s ease, top 0.3s ease, left 0.3s ease;
  pointer-events: auto !important; /* Ensure panel always captures events */
  /* Initial position will be set by adjustInitialPosition() */
}

/* Override the default style when dragging - no transitions */
.mission-simulation-panel.dragging {
  transition: none !important;
  cursor: grabbing !important;
  opacity: 0.9; /* Slight transparency while dragging */
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9) !important;
}

.mission-simulation-panel:hover {
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.9);
}

.mission-simulation-panel.dragging .header {
  cursor: grabbing;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  background-color: rgba(0, 0, 0, 0.7);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  cursor: grab;
  touch-action: none;
  user-select: none;
}

.panel-title {
  margin: 0;
  font-size: 1.25rem;
  color: var(--gecko-warning);
}

.simulation-content {
  padding: 16px;
  overflow-y: auto;
  flex: 1; /* Allow content to flex and scroll */
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.simulation-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.mission-select {
  max-width: 300px;
}

.animation-controls {
  margin-left: 16px;
}

.section {
  border: 1px solid rgba(255, 193, 7, 0.2);
  border-radius: 8px;
  margin-bottom: 1rem;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.3);
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem 1rem;
  background: rgba(0, 0, 0, 0.4);
  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s ease;
}

.section-header:hover {
  background: rgba(0, 0, 0, 0.5);
}

.section-title {
  margin: 0;
  color: var(--gecko-warning);
  font-size: 1rem;
  font-weight: 500;
}

.toggle-icon {
  color: var(--gecko-warning);
  font-size: 0.8rem;
  transition: transform 0.2s ease;
}

.section-content {
  padding: 1rem;
  background: rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease;
}

.mission-info {
  background-color: rgba(0, 0, 0, 0.7);
  border-radius: 8px;
  padding: 16px;
  border-left: 3px solid var(--gecko-warning);
}

.pattern-types {
  margin-top: 12px;
}

.pattern-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 16px;
}

.pattern-settings {
  margin-top: 24px;
}

.settings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 24px;
  margin-bottom: 20px;
}

.input-row {
  display: flex;
  gap: 12px;
}

.simulation-progress {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.progress-info {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  margin-bottom: 4px;
}

.info-stat {
  display: flex;
  align-items: center;
  gap: 4px;
}

.info-label {
  color: var(--gecko-warning);
  font-weight: bold;
}

.info-value {
  color: white;
}

/* Take-off prompt styling */
.takeoff-prompt {
  background-color: rgba(0, 0, 0, 0.95) !important;
  color: white !important;
  border: 1px solid var(--gecko-primary);
  box-shadow: 0 0 20px rgba(33, 150, 243, 0.4);
}

.takeoff-prompt .v-card-title {
  color: var(--gecko-primary);
  border-bottom: 1px solid rgba(33, 150, 243, 0.3);
  padding-bottom: 12px;
}

.takeoff-prompt .v-card-text {
  padding-top: 16px;
  color: rgba(255, 255, 255, 0.9);
}

/* Add these styles at the end of the <style> section */
.takeoff-section {
  border-color: rgba(255, 193, 7, 0.4); /* Brighter border for emphasis */
}

.takeoff-info, .takeoff-missing {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.warning-message {
  display: flex;
  align-items: center;
  gap: 8px;
  background: rgba(255, 193, 7, 0.1);
  padding: 8px;
  border-radius: 4px;
  border-left: 3px solid var(--gecko-warning);
}

.success-text {
  color: #4caf50; /* Green for success */
  font-weight: bold;
}

.face-selection-visual {
  margin-top: 12px;
}

.building-top-view {
  position: relative;
  width: 120px;
  height: 120px;
  margin: 0 auto;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

.building-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 60px;
  height: 60px;
  background-color: rgba(0, 100, 200, 0.3);
  border: 1px solid rgba(0, 100, 200, 0.6);
}

.building-face {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(100, 100, 100, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.2);
  cursor: pointer;
  font-weight: bold;
  transition: all 0.2s ease;
  color: rgba(255, 255, 255, 0.6);
}

.building-face.selected {
  background-color: rgba(255, 193, 7, 0.4);
  border-color: var(--gecko-warning);
  color: var(--gecko-warning);
}

.building-face:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

.face-0 { /* North */
  top: 0;
  left: 30px;
  width: 60px;
  height: 30px;
}

.face-1 { /* East */
  top: 30px;
  right: 0;
  width: 30px;
  height: 60px;
}

.face-2 { /* South */
  bottom: 0;
  left: 30px;
  width: 60px;
  height: 30px;
}

.face-3 { /* West */
  top: 30px;
  left: 0;
  width: 30px;
  height: 60px;
}

/* Camera and GSD Settings styles */
.camera-specs {
  background-color: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  padding: 12px;
  margin-top: 8px;
}

.spec-item {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
}

.spec-label {
  color: var(--gecko-warning);
  font-weight: 500;
}

.spec-value {
  color: white;
}

.empty-state {
  padding: 16px;
  text-align: center;
  background-color: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  color: rgba(255, 255, 255, 0.7);
  margin-top: 8px;
  font-style: italic;
}

.results-panel {
  background-color: rgba(0, 36, 81, 0.4);
  border-radius: 4px;
  padding: 16px;
  border: 1px solid rgba(33, 150, 243, 0.3);
}

.results-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.result-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.result-label {
  color: rgba(255, 255, 255, 0.8);
}

.result-value {
  font-weight: 500;
  color: var(--gecko-primary, #2196f3);
}

.info-subtitle {
  font-weight: 500;
  color: var(--gecko-primary, #2196f3);
  margin-bottom: 8px;
  margin-top: 16px;
}

.hardware-notice {
  text-align: center;
  color: rgba(255, 255, 255, 0.7);
  margin-bottom: 16px;
}

.hardware-info-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 16px;
}

.info-section {
  text-align: center;
}
</style> 